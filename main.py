# Добавление зависимостей для работы с FastAPI.
import asyncio

from fastapi import Body, FastAPI, HTTPException
from fastapi.responses import FileResponse, JSONResponse
# Добавление зависимости для выполнения вычислений, связанных с диффурами.
from scipy.integrate import odeint

# Инициализация приложения FastAPI
app = FastAPI()


def du4_dt(u, t, c):
    """
    Функция, выражающая систему уравнений Практической Работы 4.
    :param u: массив исследуемых параметров, представляющих собой функции pi(t), i=[1..2^4-1]
    :param t: массив временных точек от 0 до tn.
    :param c: словарь нормировочных множителей вида {"Название": <Значение множителя>, ...}.
    :return: массив вычисленных выражений pxi/dt, i=[0..2^4-1].
    """
    # Извлекаем элементы, которые являются исследуемыми xi(t), из массива u
    [p0_t, p1_t, p2_t, p3_t, p4_t, p5_t, p6_t, p7_t, p8_t, p9_t, p10_t, p11_t, p12_t, p13_t, p14_t, p15_t] = u

    # Для каждого уравнения приводим запись формулы из задания.
    # Для формулы:
    # dp0/dt = -p0_t * (l1 + l2 + l3 + l4) + u1 * p1_t + u2 * p2_t + u3 * p3_t + u4 * p4_t
    # программная запись примет вид:
    dp0_dt = (
        - p0_t * (c['l1'] + c['l2'] + c['l3'] + c['l4'])
        + c['u1'] * p1_t
        + c['u2'] * p2_t
        + c['u3'] * p3_t
        + c['u4'] * p4_t
    )

    # Далее по аналогии со всеми уравнениями системы.
    dp1_dt = (
        - p1_t * (c['u1'] + c['l2'] + c['l3'] + c['l4'])
        + c['l1'] * p0_t
        + c['u2'] * p5_t
        + c['u3'] * p6_t
        + c['u4'] * p7_t
    )

    dp2_dt = (
        - p2_t * (c['u2'] + c['l1'] + c['l3'] + c['l4'])
        + c['l2'] * p0_t
        + c['u1'] * p5_t
        + c['u3'] * p8_t
        + c['u4'] * p9_t
    )

    dp3_dt = (
        - p3_t * (c['u3'] + c['l1'] + c['l2'] + c['l4'])
        + c['l3'] * p0_t
        + c['u1'] * p6_t
        + c['u2'] * p8_t
        + c['u4'] * p10_t
    )

    dp4_dt = (
        - p4_t * (c['u4'] + c['l1'] + c['l2'] + c['l3'])
        + c['l3'] * p0_t
        + c['u1'] * p7_t
        + c['u2'] * p9_t
        + c['u3'] * p10_t
    )

    dp5_dt = (
        - p5_t * (c['u2'] + c['u1'] + c['l1'] + c['l4'])
        + c['l2'] * p1_t
        + c['l1'] * p2_t
        + c['u4'] * p12_t
        + c['u3'] * p11_t
    )

    dp6_dt = (
        - p6_t * (c['u3'] + c['u1'] + c['l2'] + c['l4'])
        + c['l3'] * p1_t
        + c['l1'] * p3_t
        + c['u2'] * p11_t
        + c['u4'] * p13_t
    )

    dp7_dt = (
        - p7_t * (c['u4'] + c['u1'] + c['l2'] + c['l3'])
        + c['l4'] * p1_t
        + c['l1'] * p4_t
        + c['u2'] * p12_t
        + c['u3'] * p13_t
    )

    dp8_dt = (
        - p8_t * (c['u3'] + c['u2'] + c['l1'] + c['l4'])
        + c['l3'] * p2_t
        + c['l2'] * p3_t
        + c['u1'] * p11_t
        + c['u4'] * p14_t
    )

    dp9_dt = (
        - p9_t * (c['u2'] + c['u4'] + c['l3'] + c['l1'])
        + c['l2'] * p4_t
        + c['l4'] * p2_t
        + c['u3'] * p14_t
        + c['u1'] * p12_t
    )

    dp10_dt = (
        - p10_t * (c['u3'] + c['u4'] + c['l1'] + c['l2'])
        + c['l3'] * p4_t
        + c['l4'] * p3_t
        + c['u1'] * p13_t
        + c['u2'] * p14_t
    )

    dp11_dt = (
        - p11_t * (c['u3'] + c['u2'] + c['u1'] + c['l4'])
        + c['l3'] * p5_t
        + c['l2'] * p6_t
        + c['l1'] * p8_t
        + c['u4'] * p15_t
    )

    dp12_dt = (
        - p12_t * (c['u4'] + c['u2'] + c['u1'] + c['l3'])
        + c['l4'] * p5_t
        + c['l2'] * p7_t
        + c['l1'] * p9_t
        + c['u3'] * p15_t
    )

    dp13_dt = (
        - p13_t * (c['u4'] + c['u3'] + c['u1'] + c['l2'])
        + c['l4'] * p6_t
        + c['l3'] * p7_t
        + c['l1'] * p10_t
        + c['u2'] * p15_t
    )

    dp14_dt = (
        - p14_t * (c['u4'] + c['u3'] + c['u2'] + c['l1'])
        + c['l4'] * p8_t
        + c['l3'] * p9_t
        + c['l2'] * p10_t
        + c['u1'] * p15_t
    )

    dp15_dt = (
        - p15_t * (c['u4'] + c['u3'] + c['u2'] + c['u1'])
        + c['l1'] * p14_t
        + c['l2'] * p13_t
        + c['l3'] * p12_t
        + c['l4'] * p11_t
    )

    # Возвращаем массив вычисленных dpi/dt, i=[1..16]
    return [dp0_dt, dp1_dt, dp2_dt, dp3_dt, dp4_dt, dp5_dt, dp6_dt, dp7_dt, dp8_dt, dp9_dt, dp10_dt, dp11_dt, dp12_dt, dp13_dt, dp14_dt, dp15_dt]


# Указывает маршрут /lab4 до web-интерфеса, созданного для ввода значений из Практической Работы 4
@app.get("/lab4")
async def main():
    # Возващаем в качетсве ответа HTML-страницу, расположенную по адресу ./lab4.html
    return FileResponse("lab4.html")


# Указываем маршрут /api/lab4/count, по которому можно получить результаты вычилений для Практической работы 4
# Тело данного POST-запрос имеет вид {"p0": <Словарь начальный значений>, "c": <Словарь интенсивностей отказа и восстановления>, "t": <Словарь временных параметров>}
# Записи <Словарь начальных значений> имеют вид "P0": <значение>, "P1": <значение>, ...
# Записи <Словарь интенсивностей отказа и восстановления> имеют вид "l1": <значение>, "l2": <значение>, ... , "u1": <значение>, "u2": <значение>, ...
# Записи <Словарь временных параметров> имеют вид "t0" : <начало интервала>, "tn" : <конец интервала>, "dt" : <шаг>
@app.post("/api/lab4/count")
async def count4(data=Body()):
    try:
        # Извлекаем пришедшие начальные значения в t0
        t0 = data['p0']

        # Формируем временной интервал
        t_span = []

        t_start = 0
        t_end = data['t']
        dt = t_end/20

        t_now = t_start
        while t_now < t_end:
            t_now = round(t_now, 2)
            t_span.append(t_now)
            t_now = t_now + dt

        t_span.append(t_end)

        # Извлекаем пришедшие интенсивности
        c = data['c']
        # Передаем в качетсве аргументов в функцию для решения системы диффуров odeint
        # Параметры:
        # du4_dt - ранее описанная функция, выражающая систему уравнений Практической Работы 4
        # list(t0.values()) - список начальных значений
        # t_span - временной интервал
        # args=(c,) - дополнительный аргументы в виде интенсивностей
        # full_output=True - для определения, решена ли система или нет
        # Получаем на выходе:
        # usolution - Решение системы в виде массива, элементы которого являются массивами решений для указанной точке на временной прямой
        # d - лог вычислений
        usolution, d = odeint(du4_dt, list(t0.values()), t_span, args=(c,), full_output=True)

        # Если решение не определено для заданных параметров - вернуть ошибку
        if d["message"] != "Integration successful.":
            raise HTTPException(status_code=500)
        # Преобразуем значения для отправки их в качестве JSON-ответа
        solution = [None] * len(usolution)
        idx = 0
        for elem in usolution:
            solution[idx] = list(elem)
            idx = idx + 1

        return JSONResponse(content={"solution": solution, "time": t_span})
    except:
        # При некорректно предоставленных в теле запроса данных
        raise HTTPException(status_code=500)